
//
//  Begin of autogenerated swift source code
//
//  Vgg16Builder.swift
//
//  created 2017-10-05 16:30 by keras2metal.py
//
//  Converter wittenn by Pavel Mayer, Tognos GmbH, http://tognos.com/
//  based on YADK and Forge yolo2metal.py
//

import Foundation
//import Forge
import MetalPerformanceShaders

open class Vgg16Builder : NetworkBuilder {

private(set) public var model: Model
private(set) public var device: MTLDevice
private(set) public var name = "vgg_16"

public required init(device: MTLDevice) {
  self.device = device

let relu = MPSCNNNeuronReLU(device: device, a: 0)
let input_scale = MPSCNNNeuronLinear(device: device, a: 2, b: -1)
let input = Input()
let swap_channels = Custom(TransposeChannelsKernel(device: device, featureChannels: 3, permute: [2,1,0]), name: "rgb2bgr")
let subtract_mean = Custom(SubtractMeanColor(device: device, red: 123.68, green: 116.779, blue: 103.939, scale: 255.0), name: "subtract_mean")
let input_2 = input --> Resize(width: 224, height: 224) -->  swap_channels -->  subtract_mean --> Activation(input_scale, name: "input_scale")
let block1_conv1 = Convolution(kernel: (3, 3), channels: 64, activation: relu, name: "block1_conv1")
let block1_conv2 = Convolution(kernel: (3, 3), channels: 64, activation: relu, name: "block1_conv2")
let block1_pool = MaxPooling(kernel: (2, 2), stride: (2, 2), name: "block1_pool")
let block2_conv1 = Convolution(kernel: (3, 3), channels: 128, activation: relu, name: "block2_conv1")
let block2_conv2 = Convolution(kernel: (3, 3), channels: 128, activation: relu, name: "block2_conv2")
let block2_pool = MaxPooling(kernel: (2, 2), stride: (2, 2), name: "block2_pool")
let block3_conv1 = Convolution(kernel: (3, 3), channels: 256, activation: relu, name: "block3_conv1")
let block3_conv2 = Convolution(kernel: (3, 3), channels: 256, activation: relu, name: "block3_conv2")
let block3_conv3 = Convolution(kernel: (3, 3), channels: 256, activation: relu, name: "block3_conv3")
let block3_pool = MaxPooling(kernel: (2, 2), stride: (2, 2), name: "block3_pool")
let block4_conv1 = Convolution(kernel: (3, 3), channels: 512, activation: relu, name: "block4_conv1")
let block4_conv2 = Convolution(kernel: (3, 3), channels: 512, activation: relu, name: "block4_conv2")
let block4_conv3 = Convolution(kernel: (3, 3), channels: 512, activation: relu, name: "block4_conv3")
let block4_pool = MaxPooling(kernel: (2, 2), stride: (2, 2), name: "block4_pool")
let block5_conv1 = Convolution(kernel: (3, 3), channels: 512, activation: relu, name: "block5_conv1")
let block5_conv2 = Convolution(kernel: (3, 3), channels: 512, activation: relu, name: "block5_conv2")
let block5_conv3 = Convolution(kernel: (3, 3), channels: 512, activation: relu, name: "block5_conv3")
let block5_pool = MaxPooling(kernel: (2, 2), stride: (2, 2), name: "block5_pool")
let fc1 = Dense(neurons: 4096, activation: relu, name: "fc1")
let fc2 = Dense(neurons: 4096, activation: relu, name: "fc2")
let predictions = Dense(neurons: 1000, name: "predictions")

do {
let predictions = input_2 --> block1_conv1 --> block1_conv2 --> block1_pool --> block2_conv1
         --> block2_conv2 --> block2_pool --> block3_conv1 --> block3_conv2 --> block3_conv3
         --> block3_pool --> block4_conv1 --> block4_conv2 --> block4_conv3 --> block4_pool
         --> block5_conv1 --> block5_conv2 --> block5_conv3 --> block5_pool --> fc1
         --> fc2 --> predictions
let output = predictions --> Softmax()
model = Model(input: input, output: output)
}
} // init
public func compile(inflightBuffers: Int) -> Bool {
return model.compile(device: device, inflightBuffers: inflightBuffers) { 
  name, count, type in ParameterLoaderBundle(name: name,
  count: count,
  prefix: "vgg_16-",
  suffix: type == .weights ? ".weights" : ".biases",
  ext: "bin")
}
} // func
} // class

// end of autogenerated forge net generation code
